<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>153</title>
    <script></script>
  </head>
  <body>
    <!-- Content -->
    <center>
    <h1>
        Tutorials
    </h1>
    <hr>
    <img src="logo.png" alt="logo" style="width:100%">
    </center>
    <hr>
    <!-- Index-->
    <div style="margin-left:10%;">
        <a href="../index.html">Main page</a><br>
    </div>
    <hr>
    <div style="margin-left:10%;">
        <a href="#preface">Preface</a><br>
        <a href="#requirements">System Requirements</a><br>
        <a href="#compile">Compilation</a><br>
        <a href="#install">Installation</a><br>
        <a href="#funbas">Compiling and Running the tutorial programs</a><br>
        <a href="#tut1">Hello World</a><br>
        <a href="#tut2">Control Flow, Functions</a><br>
        <a href="#tut3">Arrays- A Calculator Program</a><br>
        <a href="#tut4">Structs and Loops</a><br>
        <a href="#tut5">Object Oriented Programming and Codegen Constants</a><br>
        <a href="#tut6">Playing Sounds and Music</a><br>
        <a href="#tut7">Snake!</a><br>
        <a href="#tut8">3d Graphics- Hello World Triangle</a><br>
        <a href="#tut9">3d Graphics- Spheres, Cones and Cylinders</a><br>
        <a href="#tut10">Program 2- Mancala</a><br>
        <a href="#tut11">Metaprogramming Introduction</a><br>
        <a href="#tut12">Worksheet- A replacement for C macros</a><br>
        <a href="#tut13">Using Codegen Code to make pre-rendered graphics</a><br>
        <a href="#license">License</a><br>
    </div>
    <hr>
    <p>
        Welcome, beloved.
        <br><i>Saying, Blessed are they whose iniquities are forgiven, and whose sins are covered.</i> - Romans 4:7
    </p>
    <p>Welcome, Conquerors to the Seabass Metaprogramming Language Tutorial Series!</p>
    <h1>This tutorial series is still in development...</h1>
    <hr>
    <center>
    <h3>All Glory to the Lord Jesus Christ, who is, and who was, and who is to come, for ever. Amen.</h3>
    </center>
    <hr>
    <center>
    <h2 id="preface">Preface</h2>
    </center>
    <hr>
    <p>The Seabass metaprogramming language is a gift I have been given by our Lord Jesus Christ.</p>
    <p>These tutuorials are written so that you may learn how to write useful, interesting programs 
    in the language even if you are a beginner.</p>
    <p>This repository, every byte (Saving for accidentally included compiled binaries), is provided to you under the CC0 license- which is to say, it is
    public domain software with virtually zero restriction, not even attribution. May your joy be full.</p>
    <hr>
    <center>
    <h2 id="requirements">System Requirements</h2>
    </center>
    <hr>
    <h3>In order to install the `cbas` tool, your computer must meet these requirements</h3>
    <ol>
        <li>A compatible C compiler invocable from the command line as `cc`</li>
        <li>64 bit</li>
        <li>Byte addressable memory</li>
        <li>A C standard library with some extension functions (such as strdup)</li>
    </ol>
    <p>If you are using a <a href="https://www.microsoft.com/en-us/windows">malware</a> <a href="https://en.wikipedia.org/wiki/MacOS">operating</a> system, please be advised that
    you may have great difficulty using this software. Please consider removing it and replacing it with an actual operating system.</p>
    <p>Installing the usermode `toc` standard library is somewhat more burdensome:</p>
    <ol>
        <li>Roughly POSIX compatible</li>
        <li>A complete pthreads implementation including pthread barrier</li>
        <li>A Berkley sockets implementation with non-blocking I/O extensions.</li>
    </ol>
    <p>Your C compiler and standard library must support the following to properly support the `toc` translator:</p>
    <ol>
        <li>The "Labels as Values" extension. GCC and Clang both support it.</li>
        <li>Tail call optimization.</li>
    </ol>
    <p>The tutorial programs will require the following:</p>
    <ol>
        <li>OpenGL 1.1, with development headers on your system.</li>
        <li>SDL2 (+mixer) with development headers on your system.</li>
    </ol>
    <p>Additionally, I expect that you are adept with using your system's commandline tools, such as `cd` (Change Directory).</p>
    <p>This tutorial will not cover how to use the commandline, how to use git, etcetera.</p>
    <hr>
    <center>
    <h2 id="compile">Compilation</h2>
    </center>
    <hr>
    <ol>
        <li>Download/clone the <a href="https://github.com/gek169/seabass">development repository</a> somewhere.</li>
        <li>`cd` into it.</li>
        <li>execute `cc *.c -o cbas` or the like. Optimizations are recommended, i.e. `cc -O3 *.c -o cbas`</li>
        <li>invoke `./cbas` and ensure you see the giant ASCII heart print out.</li>
        <li>try the feature test program- run `./cbas featuretest.cbas`. Make sure it passes the tests.</li>
        <li>cd into the tests directory and invoke `../cbas vm_test.cbas`. Make sure it says codegen main executed successfully.</li>
    </ol>
    <p>If all these completed successfully, you have successfully compiled the `cbas` tool.</p>
    <hr>
    <center>
    <h2 id="install">Installation</h2>
    </center>
    <hr>
    <p>copy the `cbas` program somewhere on your system's PATH- such as `/usr/bin/` or `/usr/local/bin/`.</p>
    <p>Please also copy the contents of `library` (but not the folder itself) to `/usr/include/cbas/`</p>
    <p>You can perform the latter step automatically by executing `make install_stdlib`</p>
    <p>Once you have finished those steps, try compiling the directory listing program-</p>
    <pre><code>
        cbas tests2/dirlist.cbas
        cc -O3 auto_out.c -lm -lpthread
        #recommended for compilers that support it:
        #cc -O3 -s auto_out.c -o dirlist -lm -lpthread -fwrapv
    </code></pre>
    <p>(note that `-lm` and `-lpthread` should be replaced by equivalent linker flags to link to your math library and pthreads, respectively)</p>
    <p>After that's finished try testing it out by executing `./dirlist .`. You should see the contents of the current directory printed.</p>
    <p>There are a bunch of other test programs written and I suggest trying multiple of them to make sure your setup is working- notably the
    `sockets_test.cbas` program. Most of these test programs are in the `tests2` directory.</p>
    <p>Once you have adequately confirmed that the test programs work, you have successfully installed Seabass.</p>
    <p></p>
    <hr>
    <center>
    <h2 id="funbas">Compiling and Running the Tutorial programs</h2>
    </center>
    <hr>
    <p>The repository containing this html file contains several `.cbas` programs. cd into the top level
    directory of the repository. You compile and run each program like this:</p>
    <pre><code>
        cbas NAME.cbas
        cc -O3 auto_out.c -o NAME -lm -lSDL2 -lGL -lSDL2_mixer -fwrapv
        ./NAME
    </code></pre>
    <p>try it with the snake program.</p>
    <pre><code>
        cbas snake.cbas
        cc -O3 auto_out.c -o snake -lm -lSDL2 -lGL -lSDL2_mixer -fwrapv
        ./snake
    </code></pre>
    <p>It is played with the arrow keys. You should hear some music playing.</p>
    <img src="tutorial_images/snake_test_1.png" alt="logo" style="width:600px"><br>
    <img src="tutorial_images/snake_test_2.png" alt="logo" style="width:600px"><br>
    <p>Hit escape to quit.</p>
    <hr>
    <center>
    <h2 id="tut1">Hello World</h2>
    </center>
    <hr>
    <p>In this tutorial we will be writing a hello world program in Seabass using the `fun` library 
    (the library for doing fun programming!).</p>
    <p>Start by creating an empty file ending in `.cbas` in the directory. Use a text editor (Not a word processor).</p>
    
    
    <p>Here is the boilerplate you will need for each program:</p>
    <pre><code>
        #include "funbas.hbas"

        fn appInit():
            openWindow(
                "Joy!",
                1280,
                720
            );
            setSwapInterval(1); //enable Vsync
        end


        fn appUpdate():
            clearScreen(0.1,0.1,0.3);

            swapDisplay();
        end

        fn appClose():

            closeWindow;
        end

        fn onClick(int btn, int state):

        end

        fn onTextInput(char* text):

        end

        fn onTextEdit(char* text, int start, int length):

        end

        fn onKey(int kc, char state):
            if(state == 0 && kc == KEY_ESCAPE)
                appClose();
                sys_exit(0);
            end
        end

        fn onKeyRepeat(int kc, char state):

        end


        fn onResize(int w, int h):
            glViewport(0,0,width,height);
        end

        fn onScroll(int x, int y):

        end
    </code></pre>
    <p>Let me explain what each part of the boiler plate does.</p>
<pre><code>
    //this is a comment!
    
    //this command tells the compiler to paste the contents of the `funbas.hbas` file here.
    //the quotes means it's loading from the current directory.
    #include "funbas.hbas"


    //this is a function- the basic building-block of your programs. This one is called `appInit` and
    //it takes zero arguments.
    //this function is called when our program starts.
    fn appInit():
        //here we are calling a function taking three arguments.
        openWindow(
            "Joy!",
            1280,
            720
        );
        //this is a function taking a single argument. It enables a feature known as "vsync" which
        //basically helps stop screen tearing.
        setSwapInterval(1); //enable Vsync
    end

    //this function is our "main loop"- it is called to render every frame.
    //right now, all it does is clear the screen and update the display.
    fn appUpdate():
        clearScreen(0.1,0.1,0.3);

        swapDisplay();
    end

    //this function is called if the user clicks the "X" button on the window that we opened.
    fn appClose():
        //if a function takes zero arguments, you can call it without parentheses.
        closeWindow;
    end

    //this function is called whenever a button on the mouse is pressed or released.
    fn onClick(int btn, int state):

    end

    //this function is used for doing text input- if you want to make something
    //where the user types.
    fn onTextInput(char* text):

    end

    //This one is for doing software text input. It's used by people who write
    //fancy foreign languages like japanese.
    fn onTextEdit(char* text, int start, int length):

    end

    //when a key is pressed or released, this is called.
    fn onKey(int kc, char state):
        if(state == 0 && kc == KEY_ESCAPE)
            appClose();
            sys_exit(0);
        end
    end

    //You know how when you're typing and you hold down a key,
    //it repeats the same character over and over? This is for that.
    fn onKeyRepeat(int kc, char state):

    end

    //This is called when the window is resized.
    fn onResize(int w, int h):
        //this command tells the graphics library the dimensions of the window.
        //width and height are global variables defined in `fun.hbas`
        glViewport(0,0,width,height);
    end

    //this is called when the mouse wheel is scrolled.
    //it's both X and Y because some mice let you scroll
    //in two directions.
    fn onScroll(int x, int y):

    end
</code></pre>
    
    <p>Try putting that code into a file called `tut1.cbas`. Compile and run it like so:</p>
    <pre><code>
        cbas tut1.cbas
        cc -O3 auto_out.c -o tut1 -lm -lSDL2 -lGL -lSDL2_mixer -fwrapv
        ./tut1
    </code></pre>
    <p>(Note that depending on what system you're on the exact compiler flags may differ.)</p>
    <p>You should see something like this:</p>
    <img src="tutorial_images/boilerplate_result1.png" alt="logo" style="width:600px">
    <p>(The window should be resizable too- try resizing it)</p>
    <h3>Compiler Errors</h3>
    <p>If you tipe someting in rong or make a mistak, you may see an error like this:</p>
    <pre><code>
    gek@whitebox:~/work/funbas$ cbas tut1.cbas 
    <CBAS: Finished Tokenization>
    expression statement requires a semicolon.
    The place I was trying to find a semicolon was:
    File:Line:Col
    tut1.cbas:35:5
    ~~~~
    Note that the line number and column number
    are where the parser invoked parse_error.
    
    
    (the actual error may be slightly before,
    or on the previous line)
    I recommend looking near the location provided,
    not just that exact spot!
    </code></pre>
    <p>In the error above, notice the `File:Line:Col` notation. This indicates
    where the error occurred. Note that <b>Compiler errors are not always guaranteed
    to point at exactly where the mistake is.</b> and furthermore <b>Not all compiler
    errors emit a file, line, and column number.</b></p>
    <p>During the course of these tutorials and beyond, you may encounter some
    pretty unusual errors. It can be pretty frustrating. Here are some tips:</p>
    <ol>
    
        <li>Try ending every line in a semicolon, even if you don't need to.</li>
        <li>If you get an error that says it's in a file that doesn't exist on line 0:0, read it carefully. It may
        be from auto-generated code at compiletime, or it may be from semantic analysis.
        If you cannot discern what the error means from the message, try inserting errors
        into your code until the message changes to determine which function and which
        lines the error is in. </li>
        <li>If you get a file, line, and column number which points to the first
        non-whitespace non-comment piece of text immediately after a function, the error is likely inside the function
        body.</li>
        <li>if you get an error from calling your system's C compiler, 
        you probably messed up your compiler command somehow. If it persists
        even after checking and re-checking,
        <b>verify that the snake program compiles and runs correctly- see above.</b>
        <br>
        You may also want to try the `funbas.cbas` program, which tests 3d rendering and sound.
        
        </li>
    </ol>
    <p><b>Back to business...</b></p>
    <p>If that worked, congratulations! We're almost at hello world.</p>
    <p>First, we need to pick a font to render it in. two unencumbered public
    domain fonts are provided:<br>
    jupiteroid<br> 
    unitblock
    </p>
    <p>They are inside of the `fonts` folder in this repository. You can try either one (or both)</p>
    <p>Look inside each folder inside of `fonts` and note the names of the `.ttf` files. Pick one to be your font.</p>
    <p>Next, we need to load that font. Start be declaring a global variable to store it:</p>
    <pre><code>
    
    byte* ourFont = 0; //the variable used to store our font!
    
    
    fn appInit():
        openWindow(
            "Joy!",
            1280,
            720
        );
        setSwapInterval(1); //enable Vsync
    end
    
    // bla bla rest of code....
    </code></pre>
    <p>Now we have to *load* the font. I decided to use Jupiteroid Bold. We will use `loadFont`</p>
    <pre><code>
    
    byte* ourFont = 0; //the variable used to store our font!
                        //its name is `ourFont` and it is of type `byte*`
    
    
    fn appInit():
        openWindow(
            "Joy!",
            1280,
            720
        );
        setSwapInterval(1); //enable Vsync
        //load our font! (IMPORTANT!!!! Must be AFTER openWindow)
        ourFont = loadFont(
            //relative path to the font's .ttf file
            "fonts/jupiteroid/Bold.ttf", 
            //this is how tall each character will be, in pixels.
            128
        );
    end
    
    //...
    // bla bla rest of code....
    //...
    
    //cleanup
    fn appClose():
        //clean up!
        free(ourFont);
        closeWindow;
    end
    </code></pre> 
    <p><b>Note how the type of font is a `byte*`</b>. This is called a "pointer". This will become imporatant later.</p>
    <p>Compile the program again and make sure it's still working. If it fails, you probably
    typed in the name of the directory wrong.</p>
    <p>Now we're actually going to render some text! Go to your appUpdate function
    and enter the `beginUI` and `endUI` calls. These demarcate where we are going to render 2D graphics.</p>
    <pre><code>
    fn appUpdate():
        clearScreen(0.1,0.1,0.3);
        beginUI();

        endUI();
        swapDisplay();
        
    end
    </code></pre>    
    <p>Now decide what color you want your hello world to be. Red? Green? Blue? You'll need it as three
    numbers between 0-1 (R,G,B). I chose this bluish white color (0.8, 0.8, 1):</p>
    <pre><code>
        fn appUpdate():
            clearScreen(0.1,0.1,0.3);
            beginUI();
                //GL command to set the current color.
                glColor3f(0.8,0.8,1);

            endUI();
            swapDisplay();
        end

    </code></pre>
    <p>Now it's finally time to render our hello world! Here's the code for our `appUpdate` function:</p>
    <pre><code>
        fn appUpdate():
            clearScreen(0.1,0.1,0.3);
            beginUI();
                glColor3f(0.8,0.8,1);
                renderText(
                    //this is our text! the `\n` means `newline`.
                    "Hello World!\nEnjoying the view?", 
                    ourFont,
                    100, //this is the X coordinate of the bottom left corner of the first character.
                         //we choose 100 pixels from the left edge.
                    128, //this is the Y coordinate. We choose 128 pixels from the top of the screen.
                    128  //this is the amount of "vertical spacing" that a newline introduces.
                );
            endUI();
            swapDisplay();
        end
    </code></pre>
    <p>Compile and run it. This is what you should see:</p>
    <img src="tutorial_images/helloworld.png" alt="logo" style="width:800px">
    <h3>BONUS CONTENT</h3>
    <p>Try adding more text to the screen.</p>
    <p>Try making it so when you press KEY_A the text disappears.</p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="tut2">Control Flow, Functions</h2>
    </center>
    <hr>
    <p>In this tutorial we will be learning about how Control Flow is done in Seabass.</p>
    <p>Control flow is how you get your program to do do anything other than execute
    a linear sequence of instructions. Seabass provides these constructs:</p>
    <ol>
        <li>if- execute a block of code if an expression is non-zero.</li>
        <li>elif/elseif- execute a block of code if an expression is non-zero
        if a previous block was not executed in an `if/elif/else` chain.</li>
        <li>else- execute a block of code if no statement in an `if/elif/else` chain
        was execute.</li>
        <li>while- execute in a loop so long as an expression evaluates as non-zero.</li>
        <li>for- execute an initial expression, then run loop iterations as long
        as a condition is true, finishing each execution with a third expression.</li>
        <li>goto/jump- jump to some part of the code which has a name.</li>
        <li>switch- based on an integer expression, jump to one of a variety of labels.</li>
        <li>break- exit the current loop.</li>
        <li>continue- continue the current loop.</li>
        <li>functions- A body of code which accepts zero or more arguments and optionally returns a value.</li>
        <li>methods- special functions which reference a struct object as `this` as a secret first argument.</li>
    </ol>
    <p>These language constructs are, broadly, what you will use to write your programs
    in seabass.</p>
    <p>This tutorial will aim to teach you how to use if/elif/else and switch.</p>
    <p>Here's a small program, `controlflow.cbas` to demonstrate control flow in
    the language:</p>
    <pre><code>
    #include "funbas.hbas"

        
    byte* ourFont = 0; //the variable used to store our font!


    fn appInit():
        openWindow(
            "Joy!",
            1280,
            720
        );
        setSwapInterval(1); //enable Vsync
        //load our font! (Must be AFTER openWindow)
        ourFont = loadFont(
            "fonts/jupiteroid/Bold.ttf", 
            64
        );
    end

    int keypressed = 0;
    uint keypresses = 2;

    fn appUpdate():
        clearScreen(0.1,0.1,0.3);
        beginUI();
            glColor3f(0.8,0.8,1);
            if(keypressed)
                if(keypressed == KEY_H)
                    renderText(
                        "You are pressing H!",
                        ourFont,100,128,64
                    );
                elif(keypressed == KEY_J)
                    renderText(
                        "You are pressing J!",
                        ourFont,100,128,64
                    );
                else
                    renderText(
                        "Good!", 
                        ourFont,100,128,64
                    );
                end
            else
                renderText(
                    "Try pressing a key.",
                    ourFont,100,128,64
                );
            end
            //demo switch....
            switch(keypresses%3) mod_0, mod_1, mod_2;
            
            :mod_0
            renderText(
                    "Hey...", 
                    ourFont,100,200,64
                );

            jump after
            :mod_1
            renderText(
                    "There!", 
                    ourFont,100,200,64
                );
            jump after
            :mod_2
                
            :after
            
        endUI();
        swapDisplay();
    end

    fn appClose():
        free(ourFont);
        closeWindow;
    end

    fn onClick(int btn, int state):

    end

    fn onTextInput(char* text):

    end

    fn onTextEdit(char* text, int start, int length):

    end

    fn onKey(int kc, char state):
        if(state == 0 && kc == KEY_ESCAPE)
            appClose();
            sys_exit(0);
        end
        if(state == 1)
            keypressed = kc;
            keypresses++;
        elif(keypressed == kc)
            keypressed = 0;
        end
    end

    fn onKeyRepeat(int kc, char state):

    end


    fn onResize(int w, int h):
        glViewport(0,0,width,height);
    end

    fn onScroll(int x, int y):

    end
    </code></pre>
    <p>The code performs the following functions:</p>
    <ol>
        <li>When the user is holding down a key, a different message prints, and it varies based on the key being pressed.</li>
        <li>Depending on how many times the user has pressed a key, another message displays either "Hey..." or "There!"</li>    
    </ol>
    <p>In order to understand how, let's talk about the language constructs used in this demo:</p>
    <h3>The if-elif-else Chain</h3>
    <p>An if-elif-else chain is of the following form:</p>
    <code><pre>
    if(EXPRESSION)
        STATEMENTS
    elif(EXPRESSION)
        STATEMENTS
    else
        STATEMENTS
    end
    </code></pre>
    <p>Note that you may have as many `elif`s as you like, or none at all. However, you may at most
    one `else` in a chain, and you may either have it or not.</p>
    <p>These are valid:</p>
    <code><pre>
    int a
    if(1)
        a = 1 + 1
    end
    
    
    
    if(a != 2)
        a = 12
    else //this will execute
        //you may have nested if-elif-else chains inside of any if/elif/else clause.
        if(a == 3)
            a--
        elif(a == 2) //this executes
            a--; a++;
        else
            sys_exit(0);
        end
    end
    
    int b
    if(a-1) //this will execute
        doStuff();
    elif(a)
        doOtherStuff();
        b = 17
    end
    
    
    int c
    if(b-17)
        doStuff();
    elif(0) //never executes
        doOtherStuff();
    else //this will execute
        doYetMoreStuff();
        c = 97
    end
    
    if(c-97)
        //do nothing...
    elif(c && 0)
        //do nothing...
    
    elif(0-0)
        //do nothing...
    
    else //this executes
        doStuff();
    end
    </code></pre>
    <p>An if/elif statement accepts an integer expression between its parentheses. if the expression
    is non-zero, its body executes. Otherwise, it attempts to execute the next `elif` in the chain.</p>
    <p>Note that this syntax is <b>not</b> whitespace dependent. The ending of an `if/elif` clause
    is determined by the presence of `end`, `elif`, or `else`. </p>
    <h3>The Switch Statement</h3>
    <p>Switch in seabass accepts an integer expression in parentheses followed by a list of labels:</p>
    <code><pre>
    int a = 3;
    switch(a) label0 label1 label2 label3;
    
    //code here never executes....
    println("You will never see me!");
    sys_exit(1);
    
    
    :label0
        a = 0;
        goto last
    :label1
        a = 10;
        goto last
    :label2
        a = 20;
        goto last
    :label3 //this code will be executed...
        a = 100;
    :last
    //code.....
    </code></pre>
    <p>Note that it is a runtime error for switch to have an expression evaluating to an integer greater than
    or equal to the number of labels, or negative.</p>
    <h3>goto/jump</h3>
    <p>Seabass allows you to do `jumps` between different parts of your program:</p>
    <code><pre>
    goto skip
        println("This will never execute!!!!");
    :skip
    </pre></code>
    <p>Note that you may jump out of a scope, but not deeper into one:</p>
    <code><pre>
    int a = 12;
    
    //later...
    if(a == 12)
        println("Skipping ahead!");
        goto skip
    end
    println("Today we will be learning about the history of underwater basket weaving...");
    println("It all started when a man found some weird reeds...");
    //insert boring lesson...    
    :skip
    println("Now for the deserts...");
    </pre></code>
    <p>Here is a detailed example:</p>
    <code><pre>
    int a = 12;
    goto secret_club //ERROR! Jumps into a scope.
    if(a != 12)
    
        :secret_club
        a = 12;
        goto else_clause //ERROR! Jumps into a scope.
    else
        :else_clause
        a = 24;
        goto secret_club //ERROR! Jumps into a scope.
    end
    </pre></code>
    <p>Note that switch may not even jump out of its scope, let alone into a scope:</p>
    <code><pre>
    int a = ((uint)rand)%3;
    
    if(1)
        switch(a) lab0, lab1, lab2; //ERROR! lab0 and lab1 are not in the same scope!
        if(0)
            :lab0 
            println("Hiya!");
        end
        :lab2 //Switch can go here just fine (same scope)
        println("Whoya!");
        goto lab1 //OK
    end
    :lab1
    println("Huzzah!");
    </pre></code>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <h3>BONUS CONTENT</h3>
    <p>Try modifying the example program to print out more unique messages for different keys. Maybe KEY_BACKSPACE for instance.</p>
    <p>Try making the `switch` handle more numbers of key presses and print out more messages. Perhaps 5.</p>
    <p></p>
    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h2 id="tut3">Arrays- A Calculator Program</h2>
    </center>
    <hr>
    <p>In this tutorial we will be learning about Arrays and writing a calculator program.</p>
    <h3>Declaring an array</h3>
    <p>To declare an array variable, enter a type name followed by an integer surrounded by square brackets:</p>
    <code><pre>
    int[3] myintegers;
    </code></pre>
    <p>Note that you can do integer math inside of an array declaration:</p>
    <code><pre>
    int[1+2] myintegers;
    int[(1<<1) + 1] myintegers2;
    </code></pre>
    <p>And, if you have declared a `codegen` integer variable, you can use it as well:</p>
    <code><pre>
    //at global scope....
    codegen int MY_ARR_SIZE = 3;
    int[MY_ARR_SIZE] myintegers;
    </code></pre>
    <h3>The Calculator</h3>
    <p>Time to do some number crunching. Here's the code:</p>
    <code><pre>
        #include "funbas.hbas"
            
        byte* ourFont = 0; //the variable used to store (a pointer to) our font!
        i64[2] numbers; //the numbers for the current calculation. 64 bit signed integers.
        uint n_numbers_entered = 0; //the number of numbers entered.
        byte[257] cur_number_entry; //the text buffer for holding the current number entry.
        byte number_entry_counter = 0; //Digits in current number typed.
        int errflag =0; //if we divide by zero, this will be set.

        fn appInit():
            openWindow(
                "Joy!",
                1280,
                720
            );
            setSwapInterval(1); //enable Vsync
            //load our font! (Must be AFTER openWindow)
            ourFont = loadFont(
                "fonts/jupiteroid/Bold.ttf", 
                64
            );
            memclear(cur_number_entry,257);
        end




        fn appUpdate():
            char[50] pbuf //print buffer- used for printing numbers.
            clearScreen(0.1,0.1,0.3); //color to clear the screen to...
            //begin 2D rendering...
            beginUI();
                //color for text...
                glColor3f(0.8,0.8,1);
                //greeting message. \n means "newline"
                renderText("Welcome to Calculotron!\nUse the numberpad\nIf you don't have one\nuse the number keys\nand A(+)/S(-)/M(*)/D(/)\nC to clear.", ourFont, 612, 64,64);
                
                //if the first number has been entered, display it.
                if(n_numbers_entered >= 1)
                    itoa(pbuf, numbers[0]);
                    renderText(pbuf, ourFont, 10, 128,64);
                end
                //if the second number has been entered, display it too.
                if(n_numbers_entered >= 2)
                    itoa(pbuf, numbers[1]);
                    renderText(pbuf, ourFont, 10, 128+64,64);
                end
                //if there is something in the current entry field, display it as well.
                if(number_entry_counter)
                    //renderText("Current Entry:", ourFont, 250, 330,64);
                    renderText(cur_number_entry, ourFont, 300, 450,64);
                end
                //if an error has occurred, report it to the user and tell them what to do...
                if(errflag)
                    renderText("<ERROR> Divide by Zero!\nPress Enter or `c`\nto continue...", ourFont, 300, 450,64);
                end
            //end 2D rendering...
            endUI();
            //update the display...
            swapDisplay();
        end

        fn appClose():
            free(ourFont);
            closeWindow;
        end

        fn onClick(int btn, int state):

        end

        fn onTextInput(char* text):

        end

        fn onTextEdit(char* text, int start, int length):

        end

        //function for finishing a number entry
        fn finishNumber:
            //check for the special case that we typed just a minus sign...
            //we want to make it "-1"
            if(number_entry_counter == 1 && cur_number_entry[0] == '-')
                cur_number_entry[number_entry_counter++] = '1';
            end
            //if we haven't typed anything, and we haven't entered both numbers,
            //we want to make the number zero.
            if(number_entry_counter == 0 && n_numbers_entered < 2)
                numbers[n_numbers_entered++] = 0;
            elif(n_numbers_entered < 2)
                //if we have entered fewer than 2 numbers, add the number
                //to the list of numbers.
                numbers[n_numbers_entered++] = atoi(cur_number_entry);
            else
                //If both numbers have been entered, we want to replace the current
                //number with the number being typed.
                numbers[1] = atoi(cur_number_entry);
            end
            //reset the number entry...
            memclear(cur_number_entry, 257);
            number_entry_counter = 0;
        end

        fn onKey(int kc, char state):
            //escape is our quit key...
            if(state == 0 && kc == KEY_ESCAPE)
                appClose();
                sys_exit(0);
            end
            //This is a bit complicated...
            if(
                state == 0 &&  //a key has been released AND....
                (
                        (errflag && //a divide by zero has happened AND...
                            ( //enter/backspace was entered...
                                kc == KEY_RETURN || 
                                kc == KEY_KP_ENTER || 
                                kc == KEY_BACKSPACE
                            )
                        )
                        || //OR
                        kc == KEY_C //the C (clear) key was pressed....
                )
            )
                errflag = 0; //set error flag to zero.
                memclear(cur_number_entry, 257); //clear the text entry buffer...
                number_entry_counter = 0; //set the number entry position to zero.
                n_numbers_entered = 0; //reset the number of numbers entered.
            end
            //if a key has been released and we are not in the error state...
            if(state == 0 && !errflag)
                //if it's a number key....
                if(kc == KEY_0 || kc == KEY_KP_0)
                    cur_number_entry[number_entry_counter++] = '0';
                elif(kc == KEY_1 || kc == KEY_KP_1)
                    cur_number_entry[number_entry_counter++] = '1';
                elif(kc == KEY_2 || kc == KEY_KP_2)
                    cur_number_entry[number_entry_counter++] = '2';
                elif(kc == KEY_3 || kc == KEY_KP_3)
                    cur_number_entry[number_entry_counter++] = '3';
                elif(kc == KEY_4 || kc == KEY_KP_4)
                    cur_number_entry[number_entry_counter++] = '4';
                elif(kc == KEY_5 || kc == KEY_KP_5)
                    cur_number_entry[number_entry_counter++] = '5';
                elif(kc == KEY_6 || kc == KEY_KP_6)
                    cur_number_entry[number_entry_counter++] = '6';
                elif(kc == KEY_7 || kc == KEY_KP_7)
                    cur_number_entry[number_entry_counter++] = '7';
                elif(kc == KEY_8 || kc == KEY_KP_8)
                    cur_number_entry[number_entry_counter++] = '8';
                elif(kc == KEY_9 || kc == KEY_KP_9)
                    cur_number_entry[number_entry_counter++] = '9';
                //if we are entering the first character and we press `-` then the number is negative...
                elif(
                    (//a minus key was pressed
                        kc == KEY_MINUS ||
                        kc == KEY_KP_MINUS
                    ) && //AND
                    number_entry_counter == 0 && //the entry buffer is empty
                    (n_numbers_entered < 2) //and we have entered fewer than two numbers...
                )
                    cur_number_entry[number_entry_counter++] = '-'; //the new number starts with minus.
                //If backspace has been released and we have characters in the entry buffer,
                //delete a character from that buffer.
                elif(kc == KEY_BACKSPACE && number_entry_counter)
                    cur_number_entry[--number_entry_counter] = 0;
                //BUT if the text entry buffer is empty, then we delete a number instead.
                elif(kc == KEY_BACKSPACE && n_numbers_entered)
                    n_numbers_entered--;
                //if a number entry is in progress and the user presses enter
                //we finish the current number being entered.
                elif((kc == KEY_KP_ENTER || kc == KEY_RETURN) && number_entry_counter)
                    finishNumber();
                //but if we are not entering a number, and enter is pressed, and the number
                //of numbers entered is zero, we should reset the state of the calculator.
                elif((kc == KEY_KP_ENTER || kc == KEY_RETURN) && n_numbers_entered == 0)
                    memclear(cur_number_entry, 257);
                    number_entry_counter = 0;
                    n_numbers_entered = 0;
                    //we already know errflag is zero, so we dont need to reset it.
                //If a plus key has been pressed (the equals key is also a plus key,
                //and a stands for add)
                elif((kc == KEY_EQUALS || kc == KEY_KP_PLUS || kc == KEY_A))
                    //If the user has not typed in any numbers, we want the add/sub/mul/div keys
                    //to be aliases for "enter".
                    if(n_numbers_entered == 0)
                        finishNumber
                        return
                    //if the user has entered at least one number, but fewer than two,
                    //we attempt to finish the current number....
                    elif(n_numbers_entered < 2)
                        //if there is nothing in the number entry field, we do NOT complete
                        //an operation...
                        if(number_entry_counter == 0)
                            return
                        end
                        //finish the number in the entry field...
                        finishNumber();
                    end
                    //perform addition...
                    numbers[0] = numbers[0] + numbers[1];
                    n_numbers_entered = 1;
                //subtraction!
                elif((kc == KEY_MINUS || kc == KEY_KP_MINUS || kc == KEY_S))
                    //same story as add
                    if(n_numbers_entered == 0)
                        finishNumber
                        return
                    elif(n_numbers_entered < 2)
                        if(number_entry_counter == 0)
                            return
                        end
                        finishNumber();
                    end
                    numbers[0] = numbers[0] - numbers[1];        
                    n_numbers_entered = 1;
                //multiplication
                elif((kc == KEY_KP_STAR || kc == KEY_M))
                    //same story as add
                    if(n_numbers_entered == 0)
                        finishNumber
                        return
                    elif(n_numbers_entered < 2)
                        if(number_entry_counter == 0)
                            return
                        end
                        finishNumber();
                    end
                    numbers[0] = numbers[0] * numbers[1];
                    n_numbers_entered = 1;
                //Division!
                elif((kc == KEY_KP_SLASH || kc == KEY_D || kc == KEY_SLASH))
                    //same story as add, but...
                    if(n_numbers_entered == 0)
                        finishNumber
                        return
                    elif(n_numbers_entered < 2)
                        //this prevents erroneous presses of `/` with
                        //only one number entered causing a divide by zero error.
                        if(number_entry_counter == 0)
                            return
                        end
                        finishNumber();
                    end
                    //don't divide by zero!
                    if(numbers[1] != 0)
                        numbers[0] = numbers[0] / numbers[1];
                        n_numbers_entered = 1;
                    else
                        //error! division by zero!
                        //report it to the user.
                        numbers[0] = 0;
                        //numbers[1] is zero, so we don't have to reset it...
                        errflag = 1;
                        n_numbers_entered = 0;
                    end
                end //massive elif chain...
            end //state == 0 && !errflag
        end

        fn onKeyRepeat(int kc, char state):

        end


        fn onResize(int w, int h):
            glViewport(0,0,width,height);
        end

        fn onScroll(int x, int y):

        end

    </code></pre>
    <h3>How does it work?</h3>
    <p>Two arrays are used for user entry-</p>
    <p>The first array `numbers` stores the numbers to be used in a calculation.</p>
    <p>The second array, `cur_number_entry` stores the digits the user has typed.</p>
    <p>As the user presses digit keys, we add them to the `cur_number_entry` array.</p>
    <p>The user can press enter to complete that number and begin the next one.</p>
    <p>After both numbers have been entered, they can press an operation key (like +) to
    perform one of four mathematical operations (addition, subtraction, multiplication,
    division).</p>
    <h3>BONUS CONTENT</h3>
    <ol>
        <li>Try adding support for `modulo` (%) to the calculator when the user
        presses the `L` or `O` keys. Make sure to handle modulo by zero!</li>
        <li>Try letting the user enter more than 2 numbers at once.</li>
        <li>Try adding support for exponentiation. Bonus points if you can
        handle negative powers.</li>
    </ol>
    <hr>
    <center>
    <h2 id="tut4">Structs and Loops</h2>
    </center>
    <hr>
    <p>Seabass provides the ability to define compound data types comprised
    of multiple separate elements, called the 'struct' or 'class'.</p>
    <code><pre> 
        struct mystruct
            int a
            int b
            int c
            char d
        end
    </code></pre>
    <p>Structs may also be nested:</p>
    <code><pre>
        struct otherStruct
            mystruct mstrct
            int a
            int b
            int c
        end
    </code></pre>
    <p>You may also have pointers to structs inside of a struct:</p>
    <code><pre>
        struct otherStruct2
            otherStruct2* friend
            mystruct* otherfriend
            otherStruct othrstrct
            int a
            int b
            int c
        end
    </code></pre>
    <p>Note that a struct may not contain itself:</p>
    <code><pre>
        struct illegalStruct
            illegalStruct recursive_definition //error! Struct may not contain itself!
            int a
            int b
        end
    </code></pre>
    <p>Structs may be declared a "union" meaning that members may share the same memory:</p>
    <code><pre>
        struct myFloatIntUnion
            union //inside the struct definion...
            i32 i
            f32 f
        end
    </code></pre>
    <p>You may also specify an <i>alignment</i> for the struct by entering an integer inside the struct definition:</p>
    <code><pre>
        struct myvec4
            16 //16 byte alignment requirement...
            f32[4] f
        end
        struct mymat4
            union
            32 //32 byte alignment requirement...
            f32[16] f
            myvec4[4] col
        end
    </code></pre>
    <p>Alignment specifiers are used to indicate that the struct in question must exist only
    at memory locations divisible by a power of two.</p>
    <p>Note that it is almost always (if not actually always) an error to use a number 
    which is not a power of two. If you use an illegal alignment specifier then you 
    are likely to get an error message from your C compiler.</p>
    <p>if you do not have a real reason to use an alignment specifier, you probably
    shouldn't use one. They can cause <b><i>weird bugs</i></b> to happen.</p>
    <p></p>
    <h3>Loops</h3>
    <p>As discussed before, Seabass has two loop constructs, `while` and `for`.</p>
    <p>To explain how each one works, I will show how each one decays into `if` and `goto`.</p>
    <code><pre>
    int i = 0;
    while(i < 20)
        i++
    end
    </code></pre>
    <p>This is equivalent to the following code:</p>
    <code><pre>
    int i = 0;
    :while_top
    if(i < 20)
        i++
        goto while_top
    end
    </code></pre>
    <p>Here is an example of for:</p>
    <code><pre>
        i64 i;
        for(i = 0, i < 50, i++)
            char[50] buf
            i64 q = i * i; //calculate square...
            itoa(buf, q);
            println(buf);
        end
    </code></pre>
    <p>Which is equivalent to this code:</p>
    <code><pre>
        i64 i;
        
        i = 0
        while(i < 50)
            if(1) //a scope...
                char[50] buf
                i64 q = i * i; //calculate square...
                itoa(buf, q);
                println(buf);
            end
            i++
        end
    </code></pre>
    <p>Which can again be translated further down to if and goto like so:</p>
    <code><pre>
        i64 i;
        
        i = 0
        :while_top
        if(i < 50)
            if(1) //a scope...
                char[50] buf
                i64 q = i * i; //calculate square...
                itoa(buf, q);
                println(buf);
            end
            i++
            goto while_top
        end
    </code></pre>
    
    <p>Note that `for` allows either commas or semicolons to be used to separate
    expressions. You may even use both in the same for:</p>
    <code><pre>    
        i64 i
        for(i = 0; i <= 19, i = i + 1)
            println("You will see this print twenty times!")
        end
        for(i = 50, i > -1; --i)
            println("You will see this print fifty times!")
        end
    </code></pre>
    <hr>
    <center>
    <h2 id="tut5">Object Oriented Programming and Codegen Constants</h2>
    </center>
    <hr>
    <p>Seabass allows you to write constructors and destructors for your structs/classes:</p>
    <code><pre>
        struct mystruct
            int a
        end
        int ctr = 0;
        method mystruct.ctor:
            if(ctr == 0)
                println("Call me \"Adam\"");
            else
                println("Construction...");
            end
            this.a = ctr++
        end
        method mystruct.dtor:
            if(this.a == 0)
                println("Destroying Adam...");
            else
                println("Destruction...");
            end
            ctr--
        end
    </code></pre>
    <p>these functions must take zero arguments and return nothing. They are called when
    a struct variable (not array or pointer) is declared in a scope:</p>
    <code><pre>
        fn myFunction(int c)->int:
            mystruct f
            mystruct g
            mystruct h
            int q = h.a;
            return q + c;
        end
    </code></pre>
    <p>If you try calling myFunction, you will get a printout like this to the console:</p>
    <code><pre>
        Call me "Adam"
        Construction...
        Construction...
        Destruction...
        Destruction...
        Destroying Adam...
    </code></pre>
    <h3>Codegen Constants</h3>
    <p>Seabass allows you to define global constants using the `codegen` keyword:</p>
    <code><pre>    
        codegen int myConstant = 3;
    </code></pre>
    <p>This constant may then only be accessed either inside of the brackets of an array declaration,
    or inside of `constexpri`/`constexprf`.</p>
    <code><pre>    
        fn myFunction2:
            int getit = constexpri(myConstant); //OK
            int getit2 = myConstant; //ERROR! Codegen variable referenced in non-codegen functions...
        end
    </code></pre>
    <p>Note that as we'll discuss later, `codegen` allows you to do a lot more than just
    declare constants in your programs- you can write whole programs which run purely
    at compiletime. This functionality will be discussed later.</p>
    <hr>
    <center>
    <h2 id="tut6">Playing Sounds and Music</h2>
    </center>
    <hr>
    <p>All of our programs so far have been... rather silent. Music and sound
    add so much atmosphere to a program, don't you think? Today we'll be writing
    a program which demonstrates loading music, playing sounds, etcetera.</p>
    <code><pre>
    #include "funbas.hbas"
    
    
    byte* ourFont = 0;
    //variables to hold our sounds and music...
    byte* sound1= 0;
    byte* sound2= 0;
    byte* sound3= 0;
    byte* music1 = 0;
    byte* music2 = 0;
    
    fn appInit:
        openWindow(
            "Joy!",
            1280,
            720
        );
        setSwapInterval(1); //enable Vsync
        ourFont = loadFont(
            "fonts/jupiteroid/Bold.ttf", 
            50
        );
        //samples should be WAV, music should be MP3
        sound1 = loadSample("soundfx/Soft Blurp Hit 1 Zube Tube.wav");
        sound2 = loadSample("soundfx/Wibble Wobble Spring 1 Zube Tube.wav");
        sound3 = loadSample("soundfx/Futuristic Gun Fire Sound 7 Zube Tube.wav");
        music1 = loadMusic("music/Study and Relax.mp3");
        music2 = loadMusic("music/3 am West End.mp3");
    end
    
    fn appUpdate:
        clearScreen(0.1,0.1,0.3);
        beginUI();
            glColor3f(0.8,0.8,1);
            renderText("Press W or E to choose music track, Q for silence.\nASD play sounds.", ourFont, 0, 50,50);
        endUI();
    
        swapDisplay();
    end
    
    fn appClose:
        haltMusic();
        freeMusic(music1);
        freeMusic(music2);
        freeSample(sound1);
        freeSample(sound2);
        freeSample(sound3);
        closeWindow();
    end
    
    fn onClick(int btn, int state):
    
    end
    
    fn onTextInput(char* text):
    
    end
    
    fn onTextEdit(char* text, int start, int length):
    
    end
    
    fn onKey(int kc, char state):
        //escape key is universal quit...
        if(state == 0 && kc == KEY_ESCAPE)
            appClose();
            sys_exit(0);
        end
        if(state == 1 && kc == KEY_Q)
            haltMusic();
        elif(state == 1 && kc == KEY_W)
            haltMusic();
            playMusic(music1,
                -1, //loops. How many times do we loop? -1 for infinity.
                3000//milliseconds- fade time.
            );
        elif(state == 1 && kc == KEY_E)
            haltMusic();
            playMusic(music2,-1,3000);
        elif(state == 1 && kc == KEY_A)
            playSample(sound1,
            0 //loops. 0 for no looping.
            );
        elif(state == 1 && kc == KEY_S)
            playSample(sound2,0);
        elif(state == 1 && kc == KEY_D)
            playSample(sound3,0);
        end
    end
    
    fn onKeyRepeat(int kc, char state):
        //do nothing...
    end
    
    
    fn onResize(int w, int h):
        glViewport(0,0,w,h);
    end
    
    fn onScroll(int x, int y):
        //not interested...
    end
    </code></pre>
    <p>This program works by first loading some pieces of audio (music and sound effects) and then playing them.</p>
    <p>Now that we have established how to play music/audio in Seabass, we are ready for something big...</p>
    <hr>
    <center>
    <h2 id="tut7">Snake!</h2>
    </center>
    <hr>
    <p>This tutorial will serve to demonstrate everything from the previous tutorials to create a playable
    and fun little game.</p>
    <h3>Snake Game Synopsis</h3>
    <p>Snake is a game where you play as a hungry <i>danger noodle</i>. You're trying to eat
    a piece of food. If the snake collides with his body, the game ends (He's so hungry, he eats himself)
    but if he collides with a piece of food, he gets longer and a new piece of food appears.</p>
    <p>The difficulty of the game comes from the length of the snake- as he gets longer, maneuvering becomes
    much more difficult. Great care must be taken to avoid having the snake collide with himself.</p>
    <p>This tutorial will teach you not only how to use several new functionalities of the Seabass
    programming language (#define, move operator, and tail) but also how to render squares with OpenGL using GL_QUADS.</p>
    <p>This program is a big one, so get ready:</p>
    <code><pre>
    #include "funbas.hbas"
    
    byte* ourFont = 0;
    byte* eatSound = 0;
    byte* music = 0;
    
    //this gets re-used for the food....
    struct snake_segment
        int x
        int y
    end
    
    //constants... accessed with constexpri(NAME)
    codegen int SNAKE_MAX_SEGS = 20; //when the snake gets this long, you win!
    codegen int SCREEN_WIDTH = 128/2;
    codegen int SCREEN_HEIGHT = 72/2;
    #define DIR_UP 1
    #define DIR_LEFT 2
    #define DIR_RIGHT 3
    #define DIR_DOWN 4
    
    snake_segment[SNAKE_MAX_SEGS] segs;
    
    
    uint snake_length = 2; //start out length 2...
    
    
    
    
    int mode = -1; //-1 - waiting for user input... 0 - playing, 1 - win, 2 - lose
    int direction = DIR_RIGHT; //why not :)
    
    //we actually use a snake segment for food....
    snake_segment food;
    
    fn randomizeFood:
        food.x = ((uint)rand()) % (uint)constexpri(SCREEN_WIDTH);
        food.y = ((uint)rand()) % (uint)constexpri(SCREEN_HEIGHT);
        u64 i
        for(i = 0, i < snake_length, i++)
            if(food.x == segs[i].x && food.y == segs[i].y)
                //the food is on top of a snake segment! Recalculate...
                tail randomizeFood
            end
        end
    end
    
    procedure advanceSnake:
        //the new position...
        int nx = segs[0].x;
        int ny = segs[0].y;
        //based on direction...
        if(direction == DIR_RIGHT) 
            nx++
        elif(direction == DIR_LEFT) 
            nx--
        elif(direction == DIR_UP) 
            ny--
        elif(direction == DIR_DOWN) 
            ny++
        end
        if(nx < 0) 
            nx = nx + constexpri(SCREEN_WIDTH); 
        elif(ny < 0) 
            ny = ny + constexpri(SCREEN_HEIGHT); 
        end
        nx = nx % constexpri(SCREEN_WIDTH);
        ny = ny % constexpri(SCREEN_HEIGHT);
        i64 i
        //every segment except the first now has the position of the one ahead of it....
        for(i = snake_length-1; i > 0; i--)
            //the move operator- used to copy between pointers. Used here
            //to copy between struct variables.
            segs[i] := segs[i-1]
        end
        //the first has the new x and y...
        segs[0].x = nx;
        segs[0].y = ny;
    end
    
    proc renderSnake:
        float seg_width = (float)width / constexprf(SCREEN_WIDTH);
        float seg_height = (float)height / constexprf(SCREEN_HEIGHT);
        //the snake is white....
        //for each segment, render a square
        //equivalent to its size
        i64 i
        glColor3f(0.5,1,0.5);
        glBegin(GL_QUADS);
        for(i = 0, i < snake_length, i++)
            float x = segs[i].x * seg_width;
            float y = segs[i].y * seg_height;
            //render it....
            glVertex2f(x,y);
            glVertex2f(x+seg_width,y);
            glVertex2f(x+seg_width,y+seg_height);
            glVertex2f(x,y+seg_height);
        end
        glEnd();
    end
    
    proc renderFood:
        float seg_width = (float)width / constexprf(SCREEN_WIDTH);
        float seg_height = (float)height / constexprf(SCREEN_HEIGHT);
        
        //we render the food the same way....
        glBegin(GL_QUADS);
            float x;
            
            x = food.x * seg_width;
            float y;
            y = food.y * seg_height;
            //render it....
            glColor3f(1,0.5,0.5);
            glVertex2f(x,y);
            glVertex2f(x+seg_width,y);
            glVertex2f(x+seg_width,y+seg_height);
            glVertex2f(x,y+seg_height);
        glEnd();
    end
    
    proc checkEatFood:
        //is the snake's head on top of the food? If not, we return...
        if(segs[0].x != food.x || segs[0].y != food.y)
            return 
        end
        playSample(eatSound,0);
        //We are indeed growing...
        randomizeFood();
        snake_length++;
        //did we win?
        if(snake_length == constexpri(SNAKE_MAX_SEGS))
            snake_length--;
            //YOU WON!!!!!
            mode = 1;
            return
        end
        
        //expand our snake...
        segs[snake_length-1] := segs[snake_length-2];
    end
    
    proc checkCollide:
        int x = segs[0].x;
        int y = segs[0].y;
        
        i64 i
        for(i = 1, i < snake_length, i++)
            if(segs[i].x != x)
                continue 
            end
            if(segs[i].y != y)
                continue 
            end
            //we have a collision! The hungry snake will eat itself!
            mode = 2;
            return;
        end
    
    end
    
    fn appInit:
        openWindow(
            "Joy!",
            1280,
            720
        );
        setSwapInterval(1); //enable Vsync
        ourFont = loadFont(
            "fonts/jupiteroid/Bold.ttf", 
            128
        );
        eatSound = loadSample(
            "soundfx/Suction Hit 1 Zube Tube.wav"
        );
        music = loadMusic("music/Study and Relax.mp3");
        
        srand(unixtime);
        randomizeFood();
        segs[0].x = 10;
        segs[0].y = 10;
        segs[1].x = 9; //slightly behind....
        segs[1].y = 10;
    end
    
    
    int stall = 0; //we don't want the game to update every tick...
    int stored_direction_change = 0;
    //this is used to update the snake's direction using data from a key press...
    fn updateSnakeDir:
        if(!stored_direction_change) 
            return 
        end
        //we have an update!
        
        if(stored_direction_change == DIR_UP && direction != DIR_DOWN)
            direction = stored_direction_change
        elif(stored_direction_change == DIR_DOWN && direction != DIR_UP)
            direction = stored_direction_change
        elif(stored_direction_change == DIR_LEFT && direction != DIR_RIGHT)
            direction = stored_direction_change
        elif(stored_direction_change == DIR_RIGHT && direction != DIR_LEFT)
            direction = stored_direction_change
        end
        stored_direction_change = 0;
    end
    
    
    fn appUpdate:
        clearScreen(0.1,0.1,0.3);
        //we render snake as UI elements....
        beginUI();
            //render hello world!!!
            //glColor3f(0.8,0.8,1);
            //renderText("Hello World!\nEnjoying the view?", ourFont, 100, 128,128);
            if(mode == -1)
            
                glColor3f(0.8,0.8,1);
                renderText("Press any key", ourFont, 100, 128,128);
            elif(mode == 0)
                if(stall > 0)
                    stall--;
                else
                    stall = 5
                end
                //advance the game
                //playing the game...
                if(stall == 0)
                    updateSnakeDir();
                    advanceSnake();
                    //check if we ate the food...
                    checkEatFood();
                    checkCollide();
                end
                //render the food...
                renderFood();
                //render the snake...
                renderSnake();
                
            elif(mode == 1)
                //win
                glColor3f(0.8,0.8,1);
                renderText("You Won!", ourFont, 100, 128,128);
                glDisable(GL_BLEND);
                //render the food...
                renderFood();
                //render the snake...
                renderSnake();
            elif(mode == 2)
                //lose
                glColor3f(0.8,0.8,1);
                renderText("You Lost!", ourFont, 100, 128,128);
                glDisable(GL_BLEND);
                    //render the food...
                renderFood();
                //render the snake...
                renderSnake();
            end
    
        endUI();
    
        swapDisplay();
    end
    
    fn appClose:
        haltMusic();
        freeMusic(music);
        freeSample(eatSound);
        free(ourFont);
        closeWindow();
    end
    
    fn onClick(int btn, int state):
    
    end
    
    fn onTextInput(char* text):
    
    end
    
    fn onTextEdit(char* text, int start, int length):
    
    end
    
    fn onKey(int kc, char state):
        //escape key is universal quit...
        if(state == 0 && kc == KEY_ESCAPE)
            appClose();
            sys_exit(0);
        end
        //depending on mode...
        if(mode == -1 && state == 0)
            mode = 0;
            playMusic(music, -1, 500);
        elif(mode == 0 && state == 1)
            if(kc == KEY_UP)
                stored_direction_change = DIR_UP;
            elif(kc == KEY_LEFT)
                stored_direction_change = DIR_LEFT;
            elif(kc == KEY_RIGHT)
                stored_direction_change = DIR_RIGHT;
            elif(kc == KEY_DOWN)
                stored_direction_change = DIR_DOWN;
            end
        end
    end
    
    fn onKeyRepeat(int kc, char state):
        //do nothing...
    end
    
    
    fn onResize(int w, int h):
        glViewport(0,0,w,h);
    end
    
    fn onScroll(int x, int y):
        //not interested...
    end
    
    </code></pre>
    <h3>How does it work?</h3>
    <p><code>#define</code> is a way to do macros. We can make an identifier that behaves as if we typed a bunch of other stuff. </p>
    <p><code>glDisable(GL_BLEND)</code> disables color mixing, which is used by the text renderer, but we don't want to use it when drawing
    our snake or the food.</p>
    <p>You should be able to get most of the rest of this.</p>
    <p></p>
    <p></p>
    <p></p>
    <p>Note that the program above handles several noteworthy edge cases:</p>
    <ol>
        <li>What happens if the user presses the key to turn backwards from the direction
        they are facing? (Answer: We disallow it)</li>
        <li>How do we prevent the game from running way too fast? (Answer: we don't update the game every frame)</li>
        <li>How do we update the snake's direction responding to key presses? 
        (Answer: we cache the last key press)
        </li>
        <li>What happens when we resize the window (Answer: All rectangles are scaled/stretched)</li>
    </ol>
    <p>However this snake game does not handle...</p>
    <ol>
        <li>Storing a "move list" in case you press multiple directions between frames (The last direction key
        you pressed will be your move direction)</li>
    </ol>
    <p>Study the code carefully. It should serve as a reference for your future work.</p>
    <h3>BONUS CONTENT</h3>
    <ol>
        <li>Try changing the difficulty of the game. For instance, by changing the speed of the game
        or how long the snake has to get before you win.</li>
        <li>Try adding multiple pieces of food to the game.</li>
        <li>Try adding a special piece of food that shortens the snake rather than lengthening him.</li>
    </ol>
    
    <hr>
    <center>
    <h2 id="tut8">3d Graphics- Hello World Triangle</h2>
    </center>
    <hr>
    <p>2D is fun, but wouldn't it be much more fun to render in 3D?</p>
    <p>In this tutorial we'll be learning how to do 3D rendering Seabass
    using OpenGL 1.1. We will be doing the classic "Hello World" triangle.</p>
    <p>We're also going to be displaying rotated text. Isn't that neat?</p>
    <code><pre>
    #include "funbas.hbas"
    
    byte* fid;
    byte* fidmono;
    byte* music;
    double scrollfactor = 1;
    
    fn appInit():
        openWindow(
            "Joy!",
            1280,
            720
        );
        setSwapInterval(1); //enable Vsync
        fid = loadFont(
            "fonts/jupiteroid/Bold.ttf", 
            48
        );
        fidmono = loadFont(
            "fonts/jupiteroid/Italic.ttf", 
            64
        );
        music = loadMusic("music/3 am West End.mp3");
        playMusic(music, -1, 300);
    end
    
    double t = 0.0;
    double w = 0.0;
    
    fn appUpdate():
        clearScreen(0.1,0.1,0.3);
        glMatrixMode(GL_MODELVIEW);
        glDisable(GL_BLEND);
        glDisable(GL_CULL_FACE);
        glPushMatrix();
            glPerspective(90,(double)width/(double)height, 0.1, 100);
            glTranslatef(0, 0, -5);
            glRotatef(t*5.0, 0, 0, 1);
            glRotatef(t*7.3, 0, 1, 0);
            glScalef(scrollfactor, scrollfactor, 1);
            glBegin(GL_TRIANGLES);
                glColor3f(1,0,0); glVertex3f(-1.00,-1.00,0);
                glColor3f(0,1,0); glVertex3f(1.00,-1.00,0);
                glColor3f(0,0,1); glVertex3f(0,1.00,0);
            glEnd();
        glPopMatrix();
        
        beginUI();
            glMatrixMode(GL_MODELVIEW);
            glPushMatrix();
                glTranslatef(width/2.0, height/2.0,0);
                glRotatef(103*sinf(0.7*t), 0,0,1);
                glScalef(scrollfactor, scrollfactor, 0);
                glColor3f(0.8,0.8,1);
                renderText("Hello World!", fid, -600, -400,48);
                renderTextMono("Enjoying the View?", fidmono, 
                    -600, -50, //coordinates
                    50, //horizontal character spacing
                    64 //vertical spacing for newlines...
                );
                renderText("Let's relax a bit...", fid, -600,100,48);
            glPopMatrix();
        endUI();
    
        
        t = t + 1.0/60.0;
        w = w + 1.0/60.0;
        swapDisplay();
    end
    
    fn appClose():
        free(fid);
        free(fidmono);
        freeMusic(music);
        closeWindow;
    end
    
    fn onClick(int btn, int state):
    
    end
    
    fn onTextInput(char* text):
    
    end
    
    fn onTextEdit(char* text, int start, int length):
    
    end
    
    fn onKey(int kc, char state):
        if(state == 0 && (kc == KEY_Q || kc == KEY_ESCAPE))
            sys_exit(0);
        end
    end
    
    fn onKeyRepeat(int kc, char state):
    
    end
    
    
    fn onResize(int w, int h):
        glViewport(0,0,width,height);
    end
    
    fn onScroll(int x, int y):
        scrollfactor = scrollfactor + (f64)y/50.0
        if(scrollfactor <= 0.1)
            scrollfactor = 0.1; 
        elseif(scrollfactor > 10.0)
            scrollfactor = 10;
        end
    end
    </code></pre>
    <h3>What does it do?</h3>
    <p>Let me talk about what we do differently here:</p>
    <h3>3D rendering- not between beginUI and endUI</h3>
    <p>Until now, all rendering we have done has been inside of `beginUI` and `endUI`. These functions
    served to set up OpenGL to do 2D rendering (especially text) for us. We now want to render 3D graphics, so
    we write code outside this demarcated section.</p>
    <h3>GL_BLEND and GL_CULL_FACE</h3>
    <p>You might've noticed the call to disable <code>GL_BLEND</code> in the snake demo. It disables
    the mixing of colors, which is used by the text renderer.</p>
    <p><code>GL_CULL_FACE</code> is a little more complicated- You see, every triangle or square in OpenGL has a `winding` based on the order
    that the vertices were specified. This winding determines which side of a polygon is the "front" using the right-hand rule.
    For the purposes of this demo, we want to disable this functionality (so that when the triangle spins we can see its back side). Normally,
    3D rendering would have this enabled.</p>
    <h3>glPerspective</h3>
    <p>This non-standard GL call was added as a replacement for `gluPerspective` based on documentation from nehe.gamedev.net and Khronos.</p>
    <p>It's complicated what it does (we'd have to talk about matrix multiplication and whatnot) but essentially it creates the effect of a virtual
    camera for OpenGL. It makes things far away get smaller.</p>
    <h3>glRotatef, glTranslatef, glScalef</h3>
    <p>these calls perform simple transformations on 3D coordinates. Because of the way OpenGL works, we specify these in reverse order. Once again,
    the exact semantics of why it's in reverse order are not relevant at the moment (you can research it yourself) all you need to know is that we have to
    scale, then rotate, then translate, then do the perspective transformation <i>in that order</i> for things to look right... and OpenGL has us write it
    backwards (So we do perspective transform first, then translation, then rotation, and finally scaling).</p>
    <h3>glPushMatrix, glPopMatrix</h3>
    <p>OpenGL does transformations using "matrices". It maintains a `matrix stack`. Only the top matrix is relevant for rendering. When you
    `PushMatrix` it duplicates the top member of the stack into the next highest level. When you `popMatrix` it removes the highest layer.</p>
    <h3>Scrolling</h3>
    <p>We use SDL2's scrolling input to read the mouse wheel. This is used to allow the user to "zoom".</p>
    <h3>BONUS CONTENT</h3>
    <ol>
        <li>Try adding more triangles that spin at different rates.</li>
        <li>Try making a shape out of triangles- like a circle or a square.</li>
        <li>Try making the text rotate in interesting ways like the triangle.</li>
    </ol>
    <p></p>
    <p></p>
    <p></p>
    <code><pre>    </code></pre>
    <code><pre>    </code></pre>
    <code><pre>    </code></pre>
    <hr>
    <center>
    <h2 id="license">License</h2>
    </center>
    <hr>
    <pre>
CC0 1.0 Universal

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator and
subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for the
purpose of contributing to a commons of creative, cultural and scientific
works ("Commons") that the public can reliably and without fear of later
claims of infringement build upon, modify, incorporate in other works, reuse
and redistribute as freely as possible in any form whatsoever and for any
purposes, including without limitation commercial purposes. These owners may
contribute to the Commons to promote the ideal of a free culture and the
further production of creative, cultural and scientific works, or to gain
reputation or greater distribution for their Work in part through the use and
efforts of others.

For these and/or other purposes and motivations, and without any expectation
of additional consideration or compensation, the person associating CC0 with a
Work (the "Affirmer"), to the extent that he or she is an owner of Copyright
and Related Rights in the Work, voluntarily elects to apply CC0 to the Work
and publicly distribute the Work under its terms, with knowledge of his or her
Copyright and Related Rights in the Work and the meaning and intended legal
effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not limited
to, the following:

  i. the right to reproduce, adapt, distribute, perform, display, communicate,
  and translate a Work;

  ii. moral rights retained by the original author(s) and/or performer(s);

  iii. publicity and privacy rights pertaining to a person's image or likeness
  depicted in a Work;

  iv. rights protecting against unfair competition in regards to a Work,
  subject to the limitations in paragraph 4(a), below;

  v. rights protecting the extraction, dissemination, use and reuse of data in
  a Work;

  vi. database rights (such as those arising under Directive 96/9/EC of the
  European Parliament and of the Council of 11 March 1996 on the legal
  protection of databases, and under any national implementation thereof,
  including any amended or successor version of such directive); and

  vii. other similar, equivalent or corresponding rights throughout the world
  based on applicable law or treaty, and any national implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention of,
applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and
unconditionally waives, abandons, and surrenders all of Affirmer's Copyright
and Related Rights and associated claims and causes of action, whether now
known or unknown (including existing as well as future claims and causes of
action), in the Work (i) in all territories worldwide, (ii) for the maximum
duration provided by applicable law or treaty (including future time
extensions), (iii) in any current or future medium and for any number of
copies, and (iv) for any purpose whatsoever, including without limitation
commercial, advertising or promotional purposes (the "Waiver"). Affirmer makes
the Waiver for the benefit of each member of the public at large and to the
detriment of Affirmer's heirs and successors, fully intending that such Waiver
shall not be subject to revocation, rescission, cancellation, termination, or
any other legal or equitable action to disrupt the quiet enjoyment of the Work
by the public as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason be
judged legally invalid or ineffective under applicable law, then the Waiver
shall be preserved to the maximum extent permitted taking into account
Affirmer's express Statement of Purpose. In addition, to the extent the Waiver
is so judged Affirmer hereby grants to each affected person a royalty-free,
non transferable, non sublicensable, non exclusive, irrevocable and
unconditional license to exercise Affirmer's Copyright and Related Rights in
the Work (i) in all territories worldwide, (ii) for the maximum duration
provided by applicable law or treaty (including future time extensions), (iii)
in any current or future medium and for any number of copies, and (iv) for any
purpose whatsoever, including without limitation commercial, advertising or
promotional purposes (the "License"). The License shall be deemed effective as
of the date CC0 was applied by Affirmer to the Work. Should any part of the
License for any reason be judged legally invalid or ineffective under
applicable law, such partial invalidity or ineffectiveness shall not
invalidate the remainder of the License, and in such case Affirmer hereby
affirms that he or she will not (i) exercise any of his or her remaining
Copyright and Related Rights in the Work or (ii) assert any associated claims
and causes of action with respect to the Work, in either case contrary to
Affirmer's express Statement of Purpose.

4. Limitations and Disclaimers.

  a. No trademark or patent rights held by Affirmer are waived, abandoned,
  surrendered, licensed or otherwise affected by this document.

  b. Affirmer offers the Work as-is and makes no representations or warranties
  of any kind concerning the Work, express, implied, statutory or otherwise,
  including without limitation warranties of title, merchantability, fitness
  for a particular purpose, non infringement, or the absence of latent or
  other defects, accuracy, or the present or absence of errors, whether or not
  discoverable, all to the greatest extent permissible under applicable law.

  c. Affirmer disclaims responsibility for clearing rights of other persons
  that may apply to the Work or any use thereof, including without limitation
  any person's Copyright and Related Rights in the Work. Further, Affirmer
  disclaims responsibility for obtaining any necessary consents, permissions
  or other rights required for any use of the Work.

  d. Affirmer understands and acknowledges that Creative Commons is not a
  party to this document and has no duty or obligation with respect to this
  CC0 or use of the Work.

For more information, please see
http://creativecommons.org/publicdomain/zero/1.0/
    </pre>
    <p></p>
  </body>
</html>


